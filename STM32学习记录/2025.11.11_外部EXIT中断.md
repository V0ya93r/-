1. 中断源可以很多，EXIT外部中断,TIM,ADC,USART等
2. NVIC是内核外设，用来分配中断源的优先级，来裁量谁先给CPU执行
3. ==响应优先级==：普通排队等中断执行完
4. ==抢占优先级==：嵌套终端，直接中断目前正在中断的程序
5. 4为二进制数（0-15）决定优先级，16个优先级又按高低位分给抢占和响应


具体步骤：
1. 配置RCC，打开所有外设时钟(GPIO，AFIO，内核外设NVIC自带时钟)
2. 配置GPIO，输入模式
3. 配置AFIO，前连GPIO，后连EXTI
4. 配置EXTI，选择触发方式，触发相应方式（中断响应、事件响应）
5. 配置NVIC，给中断合适的优先级
6. 配置中断函数

```
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
```

```
GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
GPIO_InitStructure.GPIO_Speed  = GPIO_Speed_50MHz;
GPIO_Init(GPIOB,&GPIO_InitStructure);
```

```
//AFIO的配置函数在GPIO中
GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource13);
```

```
EXTI_InitTypeDef EXTI_InitStructure;
EXTI_InitStructure.EXTI_Line = EXTI_Line13;
EXTI_InitStructure.EXTI_LineCmd = ENABLE;
EXTI_InitStructure.EXTI_Mode  = 0x00;
EXTI_InitStructure.EXTI_Trigger = 0x0C;
```

```
//NVIC是内核外设，在杂项misc中找
NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
NVIC_InitTypeDef NVIC_InitStructure;
NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
NVIC_Init(&NVIC_InitStructure);
}
```

```
//从启动文件寻找中断函数
void EXTI15_10_IRQHandler(void)
{
	if(EXTI_GetITStatus(EXTI_Line13) == SET)
	{
		CountSensor_Count ++;
		EXTI_ClearITPendingBit(EXTI_Line13);
	}
	else EXTI_ClearITPendingBit(EXTI_Line13);
}
```